# Cursor Rules - Vendi Gest√£o

## üìã Contexto do Projeto

Este √© o projeto **Vendi Gest√£o**, uma plataforma web mobile-first para gest√£o de vendas e estoque de pequenos neg√≥cios de roupa infantil. O projeto utiliza Ruby on Rails 8 com padr√µes modernos de desenvolvimento.

### üìö Documenta√ß√£o do Projeto

**‚ö†Ô∏è IMPORTANTE**: Sempre consulte os documentos presentes na pasta `docs/` antes de implementar funcionalidades ou fazer altera√ß√µes significativas. Esses documentos cont√™m:

- **Especifica√ß√µes completas** (`vendi-especificacao-completa.md`) - Requisitos funcionais e n√£o funcionais detalhados
- **Design System** (`vendi-design-system.md`) - Padr√µes de UI, componentes, cores, tipografia e responsividade
- **Cronograma** (`vendi-cronograma.md`) - Roadmap, fases de desenvolvimento e status das tarefas

**Regra obrigat√≥ria**: Antes de implementar qualquer feature, funcionalidade ou componente:
1. Consulte primeiro os documentos em `docs/` para entender os requisitos
2. Verifique o design system para seguir os padr√µes de UI
3. Consulte o cronograma para entender o contexto e prioridades
4. Siga as especifica√ß√µes ao implementar funcionalidades

---

## üéØ Princ√≠pios Fundamentais

1. **CRUD primeiro**: Preferir a√ß√µes CRUD padr√£o ao inv√©s de actions customizadas
2. **Services apenas quando necess√°rio**: Usar services apenas quando a l√≥gica ficar complexa
3. **Valida√ß√µes no model**: Sempre validar no model, nunca nos services
4. **Form Objects para valida√ß√µes de formul√°rios complexos**: Usar Form Objects quando precisar validar m√∫ltiplos models ou campos que n√£o pertencem a um √∫nico model
5. **Resources com only/except**: Usar `resources` com `only:` ou `except:` para limitar a√ß√µes
6. **Multi-Account First**: Tudo deve considerar isolamento por account
7. **Pundit para autoriza√ß√£o**: Todas as a√ß√µes devem ser autorizadas
8. **Busca abstra√≠da**: Usar concern `Searchable` para l√≥gica de busca nos models
9. **Service base robusto**: Classe `Service` com m√©todos auxiliares para valida√ß√µes e tratamento de erros
10. **Responsividade First**: Layout otimizado para desktop (laptop) e mobile
11. **Mobile-First Design**: Interface pensada primeiro para mobile, depois adaptada para desktop

---

## üìÅ Estrutura de Arquivos

### Controllers

```
app/controllers/
  backoffice/
    base_controller.rb           # Base para controllers backoffice
    *_controller.rb              # Controllers espec√≠ficos
  concerns/
    authentication.rb            # Concern para autentica√ß√£o
```

**Todos os controllers devem herdar de `Backoffice::BaseController`**

### Services

```
app/services/
  service.rb                     # Classe base para services (com m√©todos auxiliares)
  backoffice/
    */                           # Namespace do recurso
      *_service.rb               # Services espec√≠ficos
```

### Models

```
app/models/
  application_record.rb          # Base para todos os models
  *.rb                          # Models espec√≠ficos
  concerns/
    searchable.rb                # Concern para busca
    *.rb                        # Outros concerns dos models
```

### Policies

```
app/policies/
  application_policy.rb          # Base para todas as policies
  backoffice_policy.rb          # Policy √∫nica para backoffice
```

### Form Objects

```
app/forms/
  *_form.rb                      # Form objects para valida√ß√µes complexas
```

### Views e Partials

**Partials locais** (como `app/views/backoffice/products/_form.html.erb`):
- ‚ö†Ô∏è **N√ÉO precisam de instru√ß√µes de uso** no topo do arquivo
- S√£o espec√≠ficos do contexto e n√£o s√£o componentes reutiliz√°veis globais
- Apenas os par√¢metros necess√°rios devem ser documentados se houver

**Partials compartilhados** (como `app/views/shared/ui/_*.html.erb`):
- ‚úÖ **Devem ter instru√ß√µes de uso** no topo do arquivo
- S√£o componentes reutiliz√°veis que podem ser usados em m√∫ltiplos contextos
- Devem documentar todos os par√¢metros e op√ß√µes dispon√≠veis

**Exemplo:**
```erb
<!-- ‚úÖ Correto - Partial local (_form.html.erb) -->
<%
  form = local_assigns[:form]
  submit_text = local_assigns[:submit_text] || "Salvar"
%>

<!-- ‚úÖ Correto - Partial compartilhado (_button.html.erb) -->
<% if false %>
  Button component
  Usage:
    <%= render 'shared/ui/button', text: "Save", variant: :primary %>
<% end %>
```

### Models Principais do Vendi Gest√£o

- `Account` (n√£o "Store") - Representa a conta/loja do usu√°rio
- `AccountConfig` (n√£o "StoreConfig") - Configura√ß√µes da conta
- `Product` - Produtos do cat√°logo
- `ProductVariant` - Varia√ß√µes por tamanho E/OU cor
- `User` - Usu√°rios/vendedores
- `Sale`, `SaleItem`, `Payment` - Vendas e pagamentos
- `Customer` - Clientes
- `Notification` - Notifica√ß√µes
- `StockMovement` - Movimenta√ß√µes de estoque

---

## üîß Padr√µes de C√≥digo

### Controllers

```ruby
# frozen_string_literal: true

module Backoffice
  class ResourceNameController < BaseController
    before_action :set_resource, only: [:show, :edit, :update, :destroy]

    def index
      @resources = current_account.resources
                                  .search(params[:search])
                                  .order(created_at: :desc)
    end

    def show
    end

    def new
      @resource = current_account.resources.build
    end

    def create
      @resource = current_account.resources.build(resource_params)

      if @resource.save
        redirect_to backoffice_resources_path, notice: "Recurso criado com sucesso"
      else
        render :new, status: :unprocessable_entity
      end
    end

    def edit
    end

    def update
      if @resource.update(resource_params)
        redirect_to backoffice_resources_path, notice: "Recurso atualizado com sucesso"
      else
        render :edit, status: :unprocessable_entity
      end
    end

    def destroy
      @resource.destroy
      redirect_to backoffice_resources_path, notice: "Recurso exclu√≠do com sucesso"
    end

    private

    def set_resource
      @resource = ResourceName.find(params[:id])
    end

    def resource_params
      params.require(:resource_name).permit(:field1, :field2, :field3)
    end
  end
end
```

**Padr√µes Importantes:**
- ‚úÖ Sempre usar `current_account` (m√©todo) para filtrar recursos
- ‚úÖ Sempre criar recursos associados ao account: `current_account.resources.build(params)`
- ‚úÖ Sempre usar `before_action :set_resource` para actions que precisam
- ‚úÖ Sempre usar strong parameters
- ‚úÖ Sempre herdar de `Backoffice::BaseController`

### Services

**Crie um service apenas quando:**
- Precisa criar/atualizar m√∫ltiplos models em uma transa√ß√£o
- Precisa executar l√≥gica complexa (emails, integra√ß√µes, c√°lculos)
- Precisa de m√∫ltiplos passos em sequ√™ncia
- A l√≥gica n√£o faz sentido estar no model ou controller

**N√£o crie um service quando:**
- √â apenas um CRUD simples
- A l√≥gica cabe em um callback do model
- √â apenas valida√ß√£o (vai no model)

**Estrutura de um Service:**

```ruby
# frozen_string_literal: true

module Backoffice
  module ResourceName
    class CreateService < Service
      attr_reader :resource, :account, :current_user

      def initialize(account:, current_user:, **params)
        super()
        @account = account
        @current_user = current_user
        @params = params
      end

      def call
        return false unless valid?

        execute_with_transaction do
          create_resource
          send_notification
          log_audit
        end
      end

      private

      def valid?
        validate_account
        validate_params
        validate_permissions
        errors.empty?
      end

      def validate_account
        validate_presence(:account, @account) &&
        validate_active(@account, attribute: :account, message: "Conta n√£o est√° ativa")
      end

      def validate_params
        # Valida√ß√µes de neg√≥cio (n√£o de dados - dados v√£o no model)
        validate_condition(
          !@account.archived?,
          attribute: :base,
          message: "N√£o √© poss√≠vel criar recursos em contas arquivadas"
        )
      end

      def validate_permissions
        # Pundit j√° faz isso no controller
        return true
      end

      def create_resource
        @resource = create_model!(
          @account.resources,
          @params,
          raise_on_error: true
        )
      end

      def send_notification
        # L√≥gica complexa (emails, etc)
      end

      def log_audit
        # Log de auditoria
      end
    end
  end
end
```

**‚ö†Ô∏è IMPORTANTE sobre Valida√ß√µes:**
- **Valida√ß√µes de dados SEMPRE no model** (presence, format, uniqueness, etc)
- **Services apenas para valida√ß√µes de neg√≥cio** (regras complexas, condi√ß√µes entre models)
- **Form Objects para valida√ß√µes de formul√°rios complexos** (m√∫ltiplos models, campos que n√£o pertencem a um √∫nico model)
- Use m√©todos auxiliares da classe `Service`: `validate_presence`, `validate_model`, `validate_condition`, etc

### Models

```ruby
# frozen_string_literal: true

class ResourceName < ApplicationRecord
  belongs_to :account

  include Searchable
  searchable_columns :name, :description, :email

  # ‚ö†Ô∏è IMPORTANTE: Valida√ß√µes SEMPRE no model
  validates :name, presence: true
  validates :email, uniqueness: { scope: :account_id }, allow_nil: true

  # Scopes
  scope :active, -> { where(active: true) }
  scope :recent, -> { order(created_at: :desc) }

  # Valores padr√£o
  after_initialize :set_defaults

  private

  def set_defaults
    if new_record?
      self.active ||= true
      self.status ||= 'pending'
    end
  end
end
```

**Padr√µes Importantes:**
- ‚úÖ Sempre incluir `belongs_to :account` e validar
- ‚úÖ Sempre validar no model (nunca no service)
- ‚úÖ Usar concern `Searchable` para busca
- ‚úÖ Valores padr√£o sempre no model com `after_initialize`
- ‚úÖ Valida√ß√µes de uniqueness com scope `:account_id` (multi-account)

### Concern Searchable

```ruby
# app/models/concerns/searchable.rb
# frozen_string_literal: true

module Searchable
  extend ActiveSupport::Concern

  included do
    scope :search, ->(term) {
      return all if term.blank?
      return all if searchable_columns.blank?

      search_term = "%#{term.strip}%"
      conditions = searchable_columns.map { |col|
        "#{table_name}.#{col} ILIKE ?"
      }.join(" OR ")

      where(conditions, *([search_term] * searchable_columns.count))
    }
  end

  class_methods do
    attr_accessor :searchable_columns

    def searchable_columns(*columns)
      @searchable_columns = columns.map(&:to_s)
    end
  end
end
```

**Uso no model:**
```ruby
class Product < ApplicationRecord
  include Searchable
  searchable_columns :name, :description, :sku
end
```

**Uso no controller:**
```ruby
def index
  @products = current_account.products.search(params[:search]).order(created_at: :desc)
end
```

### Form Objects

**Use Form Objects quando:**
- Precisa validar m√∫ltiplos models simultaneamente (ex: criar Account + User + AccountConfig)
- Campos do formul√°rio n√£o pertencem a um √∫nico model
- Precisa de valida√ß√µes customizadas que n√£o fazem sentido nos models individuais
- Quer simplificar a l√≥gica de valida√ß√£o no controller e service

**N√£o use Form Objects quando:**
- √â apenas um CRUD simples de um √∫nico model
- As valida√ß√µes j√° est√£o bem definidas no model
- N√£o h√° necessidade de validar m√∫ltiplos models juntos

**Estrutura de um Form Object:**

```ruby
# frozen_string_literal: true

class RegistrationForm
  include ActiveModel::Model
  include ActiveModel::Attributes

  # Attributes
  attribute :account_name, :string
  attribute :whatsapp, :string
  attribute :name, :string
  attribute :email, :string
  attribute :password, :string
  attribute :password_confirmation, :string

  # Validations
  validates :account_name, presence: true
  validates :whatsapp, presence: true
  validates :email, presence: true
  validates :password, presence: true, length: { minimum: 6 }
  validates :password_confirmation, presence: true
  validate :password_confirmation_matches

  # Accessors for models
  def account_attributes
    {
      name: account_name,
      whatsapp: whatsapp,
      active: true
    }
  end

  def user_attributes
    {
      name: name,
      email: email&.downcase&.strip,
      password: password,
      password_confirmation: password_confirmation,
      role: "owner"
    }
  end

  private

  def password_confirmation_matches
    return if password.blank? || password_confirmation.blank?

    unless password == password_confirmation
      errors.add(:password_confirmation, "n√£o confere")
    end
  end
end
```

**Uso no Controller:**

```ruby
def new
  @form = RegistrationForm.new
end

def create
  @form = RegistrationForm.new(registration_params)
  service = Backoffice::Accounts::CreateService.new(form: @form)

  if service.call
    redirect_to backoffice_root_path, notice: "Conta criada com sucesso!"
  else
    # Adiciona erros do service ao form
    service.errors.each do |error|
      @form.errors.add(error.attribute, error.message) unless @form.errors[error.attribute].include?(error.message)
    end

    flash.now[:alert] = "Erro ao criar conta. Verifique os campos abaixo."
    render :new, status: :unprocessable_entity
  end
end
```

**Uso no Service:**

```ruby
def initialize(form:)
  super()
  @form = form
end

def call
  return false unless @form.valid?

  execute_with_transaction do
    create_account
    create_user
    create_account_config
  end
end

private

def create_account
  @account = Account.new(
    @form.account_attributes.merge(slug: generate_slug(@form.account_name))
  )
  save_model!(@account, raise_on_error: true)
end
```

**Uso na View:**

```erb
<%= form_with model: @form, url: registration_path, method: :post, local: true do |f| %>
  <%= render 'shared/auth/input', form: f, field: :account_name, type: :text %>
  <%= render 'shared/auth/input', form: f, field: :email, type: :email %>
  <!-- Erros s√£o exibidos automaticamente via form object -->
  <%= render 'shared/auth/error_message', errors: @form.errors %>
<% end %>
```

**Padr√µes Importantes:**
- ‚úÖ Sempre usar `ActiveModel::Model` e `ActiveModel::Attributes`
- ‚úÖ Valida√ß√µes no form object, n√£o no service
- ‚úÖ M√©todos `*_attributes` para facilitar cria√ß√£o dos models
- ‚úÖ Service recebe o form object e valida apenas se ele √© v√°lido
- ‚úÖ Controller usa `form_with model: @form` para integra√ß√£o autom√°tica

### Rotas

**Sempre usar `resources` com `only:` ou `except:` para limitar a√ß√µes:**

```ruby
# ‚úÖ Correto - Todas as a√ß√µes CRUD
resources :announcements

# ‚úÖ Correto - Apenas algumas a√ß√µes
resources :messages, only: [:index, :show]

# ‚úÖ Correto - Todas exceto algumas
resources :push_notifications, only: [:new, :create]

# ‚ùå Evitar - Actions customizadas (prefira usar update com status)
resources :announcements do
  member do
    post :publish  # Se poss√≠vel, usar update com status
  end
end
```

**Preferir status como atributo ao inv√©s de actions:**
```ruby
# ‚úÖ Correto
PATCH /backoffice/announcements/:id
# params: { announcement: { status: 'published' } }

# ‚ùå Evitar
POST /backoffice/announcements/:id/publish
```

### Policies

**Usar `BackofficePolicy` √∫nica para todos os recursos:**

```ruby
# app/policies/backoffice_policy.rb
# frozen_string_literal: true

class BackofficePolicy < ApplicationPolicy
  class Scope < Scope
    def resolve
      return scope.none unless user.present?
      return scope.all if user.super_admin?
      scope.where(account: user.account)
    end
  end

  def show?
    return true if user&.super_admin?
    user.present?
  end

  def create?
    return true if user&.super_admin?
    user.present?
  end

  def update?
    return true if user&.super_admin?
    user.present?
  end

  def destroy?
    return true if user&.super_admin?
    user.present?
  end
end
```

---

## üé® UI e Design System

### Componentes Reutiliz√°veis

**SEMPRE usar componentes existentes em `app/views/shared/ui/`:**

- `_heading.html.erb` - ‚ö†Ô∏è **NUNCA escrever `<h1>`, `<h2>`, `<h3>` diretamente**
- `_button.html.erb` - Bot√µes com variantes
- `_card.html.erb` - Cards de conte√∫do
- `_badge.html.erb` - Badges de status
- `_form_input.html.erb` - Inputs de formul√°rio
- `_toast.html.erb` - Notifica√ß√µes toast

**Exemplo de uso:**
```erb
<!-- ‚úÖ Correto - Usar componente -->
<%= render 'shared/ui/heading', text: "Dashboard", size: :xl %>

<!-- ‚ùå Errado - Tag HTML direta -->
<h1>Dashboard</h1>
```

### Sistema de Toasts

**‚ö†Ô∏è IMPORTANTE**: O projeto usa **toasts ao inv√©s de flash messages**. Sempre usar toasts para feedback ao usu√°rio.

**Em controllers, usar `flash` normalmente - o layout converte automaticamente:**
```ruby
redirect_to backoffice_resources_path, notice: "Recurso criado com sucesso!"
flash.now[:error] = "Erro ao processar"
```

**Para renderizar toasts manualmente:**
```erb
<%= render 'shared/ui/toast', type: :success, message: "Produto criado com sucesso!" %>
```

### Cores do Vendi Gest√£o

```css
/* Cores Prim√°rias */
--color-vendi-green-500: #00D863;  /* Primary Green */
--color-vendi-green-600: #00B854;  /* Primary Green Dark (hover) */

/* Badges de Estoque */
/* EM ESTOQUE: badge-success (verde) */
/* BAIXO: badge-warning (laranja) */
/* SEM ESTOQUE: badge-error (vermelho) */
```

### Responsividade

**Desktop (‚â•1024px):**
- Sidebar lateral sempre vis√≠vel
- Topbar com a√ß√µes principais
- Conte√∫do centralizado com max-width

**Mobile/Tablet (<1024px):**
- Bottom navigation fixa no rodap√©
- 4 tabs principais + √∫ltimo item abre sidebar
- Layout adaptado para touch

**Breakpoints:**
- Mobile: < 768px
- Tablet: 768px - 1023px
- Desktop: ‚â• 1024px

### Tipografia

**SEMPRE usar o componente `shared/ui/heading` para t√≠tulos:**

```erb
<%= render 'shared/ui/heading', text: "Dashboard", size: :xl %>
<%= render 'shared/ui/heading', text: "Vendas de Hoje", size: :lg %>
<%= render 'shared/ui/heading', text: "Produtos em Destaque", size: :md %>

<!-- Com descri√ß√£o -->
<%= render 'shared/ui/heading',
    text: "Dashboard",
    size: :xl,
    description: "Acompanhe suas vendas e estoque em tempo real" %>
```

**Tamanhos dispon√≠veis:**
- `:xl` ‚Üí H1 (T√≠tulos de p√°gina)
- `:lg` ‚Üí H2 (T√≠tulos de se√ß√£o)
- `:md` ‚Üí H3 (Subt√≠tulos)

---

## üö´ O Que N√ÉO Fazer

1. **N√ÉO usar "Store"** - Sempre usar "Account"
2. **N√ÉO criar l√≥gica complexa em controllers** - Use services apenas quando necess√°rio
3. **N√ÉO esquecer responsividade** - Sempre testar desktop e mobile
4. **N√ÉO validar dados no service** - Valida√ß√µes sempre no model ou form object
5. **N√ÉO usar vari√°vel `@current_account`** - Sempre usar m√©todo `current_account`
6. **N√ÉO escrever tags HTML de t√≠tulo diretamente** - Sempre usar componente `heading`
7. **N√ÉO usar flash messages diretamente** - Sempre usar toasts (flash √© convertido automaticamente)
8. **N√ÉO criar services para CRUD simples** - Use apenas quando necess√°rio
9. **N√ÉO usar actions customizadas** - Prefira CRUD com status como atributo
10. **N√ÉO esquecer isolamento multi-account** - Sempre filtrar por `current_account`
11. **N√ÉO validar m√∫ltiplos models no service** - Use form object quando precisar validar m√∫ltiplos models

---

## ‚úÖ O Que Sempre Fazer

1. **SEMPRE consultar documentos em `docs/`** - Antes de implementar features, verificar especifica√ß√µes, design system e cronograma
2. **SEMPRE incluir account em queries** - `current_account.resources`
3. **SEMPRE criar recursos associados ao account** - `current_account.resources.build(params)`
4. **SEMPRE validar no model ou form object** - Nunca no service
5. **SEMPRE usar `before_action :set_resource`** - Para actions que precisam
6. **SEMPRE usar strong parameters** - Nos controllers
7. **SEMPRE usar componente heading** - Para t√≠tulos
8. **SEMPRE usar toasts** - Para feedback ao usu√°rio
9. **SEMPRE usar concern Searchable** - Para busca nos models
10. **SEMPRE usar `resources` com `only:` ou `except:`** - Nas rotas
11. **SEMPRE considerar responsividade** - Testar em desktop e mobile
12. **SEMPRE herdar de `Backoffice::BaseController`** - Para controllers backoffice
13. **SEMPRE validar uniqueness com scope** - `uniqueness: { scope: :account_id }`
14. **SEMPRE usar form object quando validar m√∫ltiplos models** - Simplifica service e controller

---

## üîê Seguran√ßa

1. **Sempre validar account_id** - N√£o confiar apenas em params
2. **Sempre autenticar** - `before_action :authenticate_user!`
3. **Sempre autorizar** - Verificar se resource pertence ao account do usu√°rio
4. **Sempre sanitizar inputs** - Strong parameters
5. **Sempre usar Pundit** - Para autoriza√ß√£o

---

## üì± Especificidades do Vendi Gest√£o

### Modelagem de Dados

- **Account** (n√£o Store) - Representa a loja/conta do usu√°rio
- **ProductVariant** - Suporta tamanho E/OU cor (n√£o apenas tamanho)
- **Sale** - Com snapshot de produtos (dados hist√≥ricos preservados)
- **StockMovement** - Auditoria completa de movimenta√ß√µes

### Varia√ß√µes de Produto

**Varia√ß√µes podem ser por tamanho E/OU cor:**
```ruby
class ProductVariant < ApplicationRecord
  belongs_to :product

  # Varia√ß√£o pode ser por tamanho E/OU cor
  # size e color s√£o ambos opcionais, mas pelo menos um deve existir
  validates :size, presence: true, if: -> { color.blank? }
  validates :color, presence: true, if: -> { size.blank? }
end
```

### Fluxo de Vendas

- Multi-step (3 passos): Selecionar Produtos ‚Üí Pagamento ‚Üí Confirma√ß√£o
- Dados tempor√°rios salvos na sess√£o durante o fluxo
- Snapshot de produtos ao criar venda (preserva hist√≥rico)
- Estoque decrementado automaticamente ao finalizar
- Suporta m√∫ltiplas formas de pagamento: PIX, Cart√£o, Dinheiro, Fiado

---

## üìù Conven√ß√µes de Nomenclatura

- **Controllers**: `ResourceNamesController` (plural, PascalCase, namespace `Backoffice`)
- **Models**: `ResourceName` (singular, PascalCase)
- **Services**: `Backoffice::ResourceNames::CreateService` (namespace, a√ß√£o)
- **Policies**: `BackofficePolicy` (√∫nica para todos os recursos)
- **Routes**: `resources :resource_names` (plural, snake_case, namespace `backoffice`)
- **Concerns**: `Searchable` (PascalCase)

---

## üß™ Checklist de Implementa√ß√£o

### Novo Recurso CRUD
- [ ] Criar migration com `account_id`
- [ ] Criar model com `belongs_to :account`
- [ ] Incluir concern `Searchable` e definir `searchable_columns` se necess√°rio
- [ ] Adicionar valida√ß√µes no model
- [ ] Adicionar scopes se necess√°rio
- [ ] Adicionar valores padr√£o com `after_initialize`
- [ ] Criar controller herdando de `Backoffice::BaseController`
- [ ] Implementar actions CRUD padr√£o
- [ ] Usar `current_account` (m√©todo) ao inv√©s de `@current_account`
- [ ] Usar `.search(params[:search])` se o model incluir `Searchable`
- [ ] Adicionar `before_action :set_resource`
- [ ] Criar `resource_params` com strong parameters
- [ ] Adicionar rotas com `resources :resource_name` no namespace `backoffice`
- [ ] Testar isolamento por account

### Novo Service (Quando Necess√°rio)
- [ ] Criar service herdando de `Service`
- [ ] Implementar `initialize` com par√¢metros
- [ ] Implementar `call` que retorna true/false
- [ ] Implementar `valid?` usando m√©todos auxiliares da classe `Service`
- [ ] Usar m√©todos auxiliares: `validate_presence`, `validate_model`, `save_model!`, etc.
- [ ] Implementar m√©todos privados para cada passo
- [ ] Usar `execute_with_transaction` para opera√ß√µes at√¥micas
- [ ] **N√ÉO** adicionar valida√ß√µes de dados (v√£o no model ou form object)
- [ ] Usar m√©todos auxiliares para tratamento de erros de models

### Novo Form Object (Quando Necess√°rio)
- [ ] Criar form object em `app/forms/`
- [ ] Incluir `ActiveModel::Model` e `ActiveModel::Attributes`
- [ ] Definir attributes com `attribute :field_name, :type`
- [ ] Adicionar valida√ß√µes usando `validates` e `validate`
- [ ] Criar m√©todos `*_attributes` para facilitar cria√ß√£o dos models
- [ ] Usar no controller com `form_with model: @form`
- [ ] Passar form object para o service ao inv√©s de params brutos
- [ ] Service valida apenas se form √© v√°lido: `return false unless @form.valid?`

---

## üéØ Regras Obrigat√≥rias que NUNCA Devem Ser Violadas

1. **Valida√ß√µes SEMPRE no model ou form object**, nunca no service
2. **Sempre usar m√©todo `current_account`** (n√£o vari√°vel `@current_account`) em queries
3. **Sempre criar recursos associados ao account** via `current_account.resources.build`
4. **Sempre usar strong parameters** nos controllers
5. **Sempre herdar de `Backoffice::BaseController`** para controllers backoffice
6. **Sempre usar `resources` com `only:` ou `except:`** nas rotas
7. **Preferir CRUD actions** ao inv√©s de actions customizadas
8. **Usar services apenas quando necess√°rio** (l√≥gica complexa, m√∫ltiplos models)
9. **Sempre usar `before_action :set_resource`** para actions que precisam
10. **Valores padr√£o sempre no model** com `after_initialize`
11. **Usar concern `Searchable`** para busca nos models
12. **Usar m√©todos auxiliares da classe `Service`** para valida√ß√µes e tratamento de erros
13. **NUNCA escrever tags HTML de t√≠tulo diretamente** - Sempre usar componente `heading`
14. **NUNCA usar flash messages diretamente** - Sempre usar toasts
15. **Usar form object quando validar m√∫ltiplos models** - Simplifica service e controller
16. **Verificar atributos booleanos usando ? (ex: @model.active?)

---

**FIM DO DOCUMENTO**

Este arquivo `.cursorrules` consolida todos os padr√µes de desenvolvimento do projeto Vendi Gest√£o, garantindo consist√™ncia, manutenibilidade e simplicidade do c√≥digo.
